<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href = "syssec.css">
    <title>Document</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>


    <div class="topnav">
        <a class="active" href="index.html">Home</a>
      </div>
      
     
   
<script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>
<div class="container">
  <div class="meta"> 
    <div class="image"></div>
    <div class="info"> 
      <h1>System Security </h1>
      <p class="subtitle">Lecture Notes</p>
      <div class="author">
        <div class="authorImage"></div>
        <div class="authorInfo">
          <div class="authorName"><a href="https://github.com/AmroAbdrabo">Amro Abdrabo</a></div>
          <div class="authorSub">Feb. 22 <span class="median-divider"> </span> </div>
        </div>
      </div>
    </div>
  </div>
  <main class="article">

    <h2>Lecture 9: Designing Secure Systems based on Trustworthy Computing and Attestation  </h2>
    <p>
    <span class = "first-letter">C</span>ore question: how can we achieve integrity assurance for code execution on remote platforms if part of the system is untrusted? To validate the local system we can not rely on the local system to show us that the system is working OK, since the local system can be corrupted and display 
    no issues upon verification. We therefore depend on a trusted external verifier. We assume the local hardware is correct, i.e. the hardware is the <b>root of trust</b>. We assume a remote adversary (launches network-based attacks). 
    </p>

    <p>
        Hardware-based backdoors like the type introduced <a href="https://www.bloomberg.com/news/features/2018-10-04/the-big-hack-how-china-used-a-tiny-chip-to-infiltrate-america-s-top-companies">here</a> are hard to defend against and require the use of specialized X-ray devices to compare, at the gate level, a normal 
        chip versus a suspected chip. 
    </p>

    <p>
        There are currently 3 approaches to achieve trustworthy execution (evaluated metric is size of TCB-trusted computing base):
    </p>
    <ul>
        <li>
            Program code in ROM
        </li>
        <li>
            Secure boot
        </li>
        <li>
            Virtual-machine-based isolation
        </li>
    </ul>
    

    <h2>Program code in ROM</h2>
    <p>
        This approach consists of keeping entire program in ROM.  <br>
        <b>Advantages:</b>  simplicity and that the adversary cannot inject any additional software. <br> <b> Disadvantages: </b> software
        cannot be updated without exchanging the ROM, adversary can use control-flow-attack (ROP), and the entire system is in TCB (no isolation).  Verdict: impractical since code needs to be updated.  
    </p>

    <h2>Secure or verified boot</h2>
    <p>
    The bootloader, which is in read only memory, loads other pieces of software and verifies digital signatures on each piece of software. <br>
    <b>Advantages:</b> only approved software can be loaded. <br>
    <b>Disadvantages:</b> Large OS almost certainly has vulnerability thus isolation amongst components not guaranteed \(\rightarrow \) entire system in TCB. The bootloader only verifies at 
    <b>launch time</b> however at runtime a ROP attack may be going on.  
    </p>
    <p>
        Note that signed code is not enough since the signing key may be compromised and an attacker thus signing his malicious software with a trusted signing key. Further,
        rollback attacks to previous signed software which was found to be vulnerable need to be prevented \(\rightarrow\) append-only hash chain in NV-RAM. 
    </p>

    <h2>Virtual-machine-based isolation</h2>
    <p>
        Consists of isolating applications by executing them inside different virtual machines. <br>
        <b>Advantages:</b> VMM (VM monitor) smaller than OS and assumed to be secure, smaller TCB, isolation between applications.
        <br> <b>Disadvantages:</b> VMM usually still large and part of TCB, relatively complex for the average user, and complicates interaction between applications.

    </p>
    <p>
        A verifier can be thought of as a reference to a "golden" database of expected software. A verifier sends a nonce to a system it wants to verify and receives from the system Sig(nonce, code).  
    </p>
    <p>
        Given that systems need to be compatible with legacy vulnerable software the only approach is to achieve security for small subset of the system. The approach has 3 steps:
    </p>

    <ol>
        <li>
            Establish isolated execution environment (EE) through hardware
        </li>
        <li>
            Externally validate correctness of EE via remote attestation
        </li>
        <li>
            Enable secure local execution and fetching of secret data through sealed storage
        </li>
    </ol>

    <p>
        The Trusted Computing Group (TCG) proposed a Trusted Platform Module (TPM) chip which is a low-cost passive device that provides platform identity, remote attestation, 
        sealed storage, and a secure counter. To simplify matters, we assume there is only a <b>public-private key pair per TPM</b> that is being used for all the operations. 
    </p>


    <h2>Lecture 11: IoT Security</h2>
    <p>
      <span class="first-letter">A</span>n example of a naive IoT protocol is that implemented by the ZigBee Light Link,
      where a network switch enrypts a network key using a master ZLL key and sends the encrypted key to the light bulb for further communication using the encryption network key. For example, the 
      switch can then send \( E_{network\ key}[On\ command] \) to switch on the bulb. The problem is that anyone can desolder the processor of the bulb and extract the master key shared by all light bulbs. The attacker who has this key can then change the network key, force a light bulb to blink for 18 hours, or factory reset. 
      The attacker need not be in proximity of the victim bulb to perform this attack since an antenna suffices to attain the desired signal strength. 
    </p>

    <p>
        ZigBee enables over-the-air updates which should be verified using asymmetric crypto, thereby having a different public key for each bulb. However, it was noticed that when the bulbs sent a request for updates from Philips servers, the servers responded with the same 
        message (called firmware1.img on the slides) for the same update version of course. Thus, the servers signed the message with same global public key that was assigned to all bulbs. Asymmetric cyptography was clearly not used. 
    </p>
    <p>
        Since the public signing and encryption key is symmetric we 
        can extract it by applying differential power analysis on the bulb's processor which allows uncovering the key and hence sending
        any update to the bulbs.  
    </p>
    <p>
        IoT devices are prone to worms since they are vulnerable, have a radio, and can be infected via radio commands. Thus, IoT devices can infect other devices. To find how many devices are needed to infect all devices in a range is given by <b>percolation theory</b>. Assuming all the devices are uniformly randomly distributed  in an area <i>A</i> and that the 
        radius of operation of each device is <i>R</i> then the number of <b>initially-infected</b> devices needed to spread to all other devices is: \[ N = 1.128 \frac{A}{\pi R^2}\]
        Possible attacks include hardware bricking (physically destroying the hardware), 2.4 GHz jamming (other devices can no longer communicate in this frequency band), and triggering epileptic seizures. 
    </p>
    <p>
        <b>Myth</b>: short range communication means no adversary can eavesdrop the communication if she is not nearby. With the appropriate antenna and amplifier, wireless signals can be eavesdropped or injected from large distances (more than a kilometer). 
    </p>

    <p>
        The IETF has tried to standardize IoT by creating a potential IoT protocol stack that is <b>interoperable</b> (unified for all devices) and <b>lightweight</b>: <img src="img/iotlayers.png" alt="" style = "width: 50%; height: auto; margin-left: auto; margin-right: auto; display: block;">
       <br> In reality however, IoT devices such as Bluetooth, ZigBee, WiFi, LoRa, all have different IoT stacks. Many IoT devices such as ZigBee use a <b>sort of</b> standardized stack such as <br> <img src="img/iotlay.png" alt="" style = "width: 30%; height: auto; margin-left: auto; margin-right: auto; display: block;"> 
       <br>where green indicates that a feature has security options. As many small devices are low power, it is uncertain whether they will ever be able to use the full IP protocol stack, hence the need for these IoT stacks. 
    </p>
    <p>
        Encryption is not enough since for ZigBee, BLE, and WiFi the MAC address is in cleartext and events (such as switching on a IoT device) are marked by sharp rise in bitrate (B/s). For example, an attacker can infer a user's home activity from encrypted traffic by monitoring device MAC addresses as well as traffic volume: <br>  
        <img src="img/events.png" alt="" style = "width: 50%; height: auto; margin-left: auto; margin-right: auto; display: block;"> <br>
        This attack involves machine learning to derive the device state, and thus derive the user behavior.
    </p>
    <p>
        This type of attack is caused by an <strong>existential leakage</strong> based on the time of transmission of a <b>single message</b>, as opposed to <strong>statistical leakage</strong> which is based on <b>changes in the sending rate over an interval.</b> The former can not be fully eliminated as it requires sending messages at the application's time resolution (not possible with battery-powered device), whereas the latter can be eliminated, albeit costly.  
        Unfortunately, hiding transmission times alone does not secure information. 
    </p>
    <p>
        In VoIP (voice over IP), sound signals are compressed using <span style = "color: blue"> variable-bit-rate</span> codecs and compressed using <span style="color: blue;">length-preserving</span> stream ciphers. As such, the length of the encrypted packet leaks information about the phonemes. 
        An illustration of the process is shown <img src="img/voip.png" alt="" style = "width: 50%; height: auto; margin-left: auto; margin-right: auto; display: block;"> note that phoneme segmenation is achieved by ML at 94% accuracy and phoneme classification is at 45% accuracy. Recovered sentences are then METEOR-scored. 
    </p>

    <p>
        Another data leakage despite encryption is auto-suggest which leaks character pressed, based on the size of the returned matches. To mitigate this, a website must make sure all auto-suggest packets are of the same length and that there is no detectable timing difference for characters that return long number of matches versus short number of matches. 
         
        GIFs, which use run-length compression, are prone to side channels. For example, an investment website which displays the percentage of investment funds by value on a pie chart GIF leaks information
        about the percentages of the funds since the angles are leaked. Changes in angle are mapped to changes in stock prices, and the exact companies being invested in are thus found. Run-length compression is done on a line-by-line basis. 
        <img src="img/pie.png" alt="" style="width: 65%; height: auto; margin-left: auto; margin-right: auto; display: block;">
    </p>
    
    <p>
        <strong>Case study: Device Pairing</strong> <br>
        Pairing: the process of establishing a <span style="color: green;">security association</span> between two devices that <span style = "color: red;">share no prior knowledge</span>. Secure device pairing requires the pairing process to be resilient against a MITM attack.
        There are two types of secure pairing: the first relies on a secondary channel called OOB (out of band) channel, and the other does not use OOB. The OOB channel has limited bandwidth capacity. 
        <br>  Two types of OOB channels 
    </p>
        <ul>
            <li><b>Human perceivable:</b>  Visible Light Communication, 
                visual, infrared Data Association, audio, haptic, and sensing
             </li>
            <li>
                <b>Physically-constrained:</b> WiFi, Bluetooth 
                (both not recommended due to amplification of signal with antennas and amplifiers), 
                near-field communication (NFC), ultrasound
            </li>
        </ul> 
       
    
    <p>
        An example of haptic OOB channel is placing two phones in one's hand and shaking them. The accelerometer of the two phones show the same readings and these readings are used to make a shared DH key. 
    </p>


    
  </main>
</div>
</body>
</html>